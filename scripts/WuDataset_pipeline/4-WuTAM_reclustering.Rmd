
---
title: "TAMs Reclustering and Signature Analysis"
author: "elopezhuerta"
date: "2025-11-04"
output: html_document
---

```{r setup, include=FALSE}
library(knitr)
opts_chunk$set(echo = TRUE)
```

# Introduction
This R Markdown document processes the TAMs from Wu BRCA dataset by selecting and reclustering. Outputs include Seurat object including only TAMs.

# Load Libraries
```{r}
library(Seurat)
library(RColorBrewer)
library(ggplot2)
library(dplyr)
library(tibble)
library(stringr)
library(gridExtra)
library(org.Hs.eg.db)
library(limma)
library(cowplot)
library(plyr)
```

# Load Input Data
```{r}
annotated_seurat <- readRDS("results/seurat_objects/WuDataset/Refined_Annotated.rds")
# Seurat object with unprocessed cells from all patients
Raw_WuDataset <- readRDS("results/seurat_objects/WuDataset/Raw_WuDataset.rds")
# Remove columns with previous annotations to use our own column.
Raw_WuDataset@meta.data[,c("celltype_subset","celltype_minor","celltype_major")] <- NULL
```

# TAM selection
We will re-cluster TAMs using the raw dataset to avoid previous calculations of
normalization, variable genes (from cell types other than macrophages), and 
clustering involving others data from other cell types
```{r}
# Getting ID of TAMs to subset from Seurat containing all TME cells
TAMs.ID <- WhichCells(annotated_seurat, idents = c("TAMs","Cycling TAMs"))
S.Obj <- Raw_WuDataset[, TAMs.ID]
# Free RAM removing large Seurat objects
rm(annotated_seurat, Raw_WuDataset)
```

# Sample pre treatment before clustering
Samples with less than 200 cells will get error in FindIntegrationAnchors function (k.filter=200). Is necessary to either drop them or merge samples with few cells 
with samples with more abundant cells.
To alter as little samples as possible, we will only merge samples with < 200

```{r}
# Sorting samples by cell abundance
samp.size <- sort(table(S.Obj$orig.ident), decreasing = TRUE)

# Select samples with < 200
samp.name <- names(samp.size)[samp.size <= 210]

# Spliting samples with < 200 in two halves
first_half <- samp.name[1:(length(samp.name) / 2)]
second_half <- rev(samp.name)[1:(length(samp.name) / 2)]

# Create the new merged names
# Only iterate up to the length of the *shorter* half to ensure only pairs are merged
merged_names <- paste(first_half, second_half, sep = "_")
samples_to_replace <- unlist(stringr::str_split(merged_names,"_"))

# Create the new column and vectorize the replacement
S.Obj$merged_samples <- as.character(S.Obj$orig.ident)

# Create a named vector for mapping replacements
replacement_map <- setNames(rep(merged_names, each = 2), samples_to_replace)

# Use the map to replace values directly (vectorized lookup)
S.Obj$merged_samples <- replacement_map[S.Obj$merged_samples]

# Unmatched keys result in NA. So restore them.
is_na <- is.na(S.Obj$merged_samples)
S.Obj$merged_samples[is_na] <- as.character(S.Obj$orig.ident[is_na])
```

# Re-clustering
```{r}
Merg_list <- SplitObject(S.Obj, split.by = "merged_samples")
rm(S.Obj)
# Fresh calculations for normalization and variable feature
for (ii in seq_along(Merg_list)) {
  Merg_list[[ii]] <- NormalizeData(Merg_list[[ii]], verbose = FALSE)
  Merg_list[[ii]] <- FindVariableFeatures(Merg_list[[ii]], selection.method = "vst", nfeatures = 2000, verbose = FALSE)
}
# FResh clustering
Merg.anchors <- FindIntegrationAnchors(object.list = Merg_list, dims = 1:30)
Merg.anchors <- IntegrateData(anchorset = Merg.anchors, dims = 1:30)
DefaultAssay(Merg.anchors) <- "integrated"
Merg.anchors <- ScaleData(Merg.anchors, verbose = FALSE)
Merg.anchors <- RunPCA(Merg.anchors, npcs = 30, verbose = FALSE)
Merg.anchors <- RunUMAP(Merg.anchors, reduction = "pca", dims = 1:30)
Merg.anchors <- FindNeighbors(Merg.anchors, dims = 1:10)
Merg.anchors <- FindClusters(Merg.anchors, resolution = 1)
```


# Macrophage corroboration
Corroborate that every cell is a macrophage by analyzing pathways represented by 
its DEGs by cluster. 
```{r}
# Calculate DEGs by cluster
ClustMarkers <- FindAllMarkers(Merg.anchors, only.pos = TRUE, assay = "RNA", min.pct = 0.25, min.cells.feature = 15)
DF_Mark <- ClustMarkers %>%
  group_by(cluster) %>%
  slice_max(n = 20, order_by = avg_log2FC)
# Turn dataframe into list
SIGNATURES <- lapply(split(DF_Mark, DF_Mark$cluster), function(df) head(df$gene, 10))
names(SIGNATURES) <- sapply(SIGNATURES, function(x) x[1])
# Calculate enrichment
Merg.anchors.scores <- AddModuleScore(Merg.anchors, features = SIGNATURES, ctrl = 20, name = "score", assay = "RNA")
```

# Pathway Enrichment Analysis
The aim is to corroborate that DEGs are not involved in pathways unrelated to 
macrophages processes. If there are clusters  with DEGs unrelated to macrophage 
processes, remove cluster and repeat clustering with raw dataset
```{r}
PathDF <- getKEGGPathwayNames(species = "hsa", remove.qualifier = TRUE)
colnames(PathDF) <- c("ID", "Pathway")
#PathDF<-column_to_rownames(PathDF, var = "PathwayID")
path_enrich<-function(i){
  print(i)
  color<-as.data.frame(SIGNATURES[[i]])
  color$EntrezID <- mapIds(org.Hs.eg.db,keys=color[,1],
                           column="ENTREZID",
                           keytype="SYMBOL",
                           multiVals="first")
  #enrichment with GO and KEGG databases
  goRest<-goana(color$EntrezID, species="Hs")
  k<-kegga(color$EntrezID, species="Hs")
  #A?adiendo nombre largo a KEGG
  k$ID<-stringr::str_remove_all(rownames(k),"path:")
  k$Pathway<-NULL
  k<-left_join(k,PathDF, by="ID")
  #Dejandola en rownames (donde estaban)
  k<-column_to_rownames(k, var="ID")
  #Sorting pathways with pval<0.01 in both databases (GO/KEGG)
  goSort<-goRest%>%
    filter(Ont%in%"BP"&P.DE<0.01)%>%
    arrange(P.DE)
  KEGGSort<-k%>%
    filter(P.DE<0.01)%>%
    arrange(P.DE)
  KEGGSort$Ont<-rep("KEGG",nrow(KEGGSort))
  #Re ordenando columnas de KEGGSort
  KEGGSort<-KEGGSort[,order(match(colnames(KEGGSort),c("Pathway","Ont","N","DE","P.DE")))]
  colnames(KEGGSort)<-colnames(goSort)
  pathways<-rbind(goSort,KEGGSort)
  rownames_to_column(pathways, var = "ID")
}
pathways<-lapply(c(1:length(SIGNATURES)),FUN = "path_enrich")
#Choosing top 5 pathways of each database (GO/KEGG)
path_plots<-vector("list", length(pathways))
for (i in 1:length(pathways)){
  path<-pathways[[i]]
  #Removing pathways with more than 1000 genes beacause they are not descriptive enough
  path_plots[[i]]<-path%>%filter(N<900)%>%
    #Top 6 pathways of GO and KEGG
    group_by(Ont)%>%
    slice_min(n = 5, order_by = P.DE)
}
names(path_plots)<-names(SIGNATURES)

#Concatenating every dataframe (DF) into a list of DF
list_DF<-function(i){
  #Creating vector with name of every Cell cluster (Module)
  neun_col<-rep(names(path_plots[i]),nrow(path_plots[[i]]))
  #Adding column with names of their respective cell cluster (Module)
  path_plots[[i]]$"Module"<-neun_col
  DFL<-as.data.frame(path_plots[[i]])
}
DF_list<-lapply(c(1:length(path_plots)),FUN = "list_DF")

#Concatenating every DF into single unified DF
D<-do.call("rbind",DF_list)

#Separating GO results from KEGG
DL<-group_split(D, Ont)
library(ggplot2)
#Colour palette
paleta<-RColorBrewer::brewer.pal(9, "Greens")[2:9]
#Choose database to creat graph
base<-c("GO", "KEGG")
PLIST<-list()
for (i in 1:length(DL)) {
  DF<-as.data.frame(DL[[i]])
  DF$Pathway<-factor(DF$Term, levels=unique(DF$Term))
  DF$Module<-factor(DF$Module, levels=unique(DF$Module))
  #Calculating ratio of genes participating (DF$DE) in the complete list of genes (DF$N) in every pathway
  DF$GeneRatio<-DF$DE/DF$N
  
  PLIST[[i]]<-ggplot(DF, aes(x= Module, y= Pathway, fill=GeneRatio))+
    geom_tile()+
    #setting white background
    theme_classic()+
    #Choosing colour and title
    scale_fill_gradientn(colours = paleta)+
    ggtitle(paste(base[i]," pathways"))+
    #x thick marks orientation and vertical dashlines 
    theme(axis.text.x=element_text(angle = 45, hjust = 1, vjust = 1, size = rel(0.8)),
          panel.border = element_rect(fill=NA),
          axis.title = element_blank(),
          axis.text.y = element_text(size = rel(0.8)),
          axis.ticks.y = element_blank(),
          axis.ticks.x = element_blank())
}
# Plot KEGG and Go proceses
cowplot::plot_grid(PLIST[[1]], PLIST[[2]],ncol = 2)

```

# Saving file
```{r}
# Defining as TAMs
Merg.anchors$celltypes <- "TAMs"
saveRDS(Merg.anchors, file = "results/seurat_objects/WuTAM_analysis/WuTAMs.rds")
```
